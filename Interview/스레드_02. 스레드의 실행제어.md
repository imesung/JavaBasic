## 스레드의 실행제어

- 스레드 프로그래밍이 어려운 이유는 동기화(synchronization)와 스케줄링(scheduling) 때문이다.

- 스레드와 멀티 스레드를 효율적으로 사용하기 위해서는 보다 정교한 스케줄링이 필요하며, 스케줄링을 잘 하기 위해서는 **스레드의 상태와 관련 메소드** 를 잘 알아야 한다.

  

*스레드 관련 메소드*

![image](https://user-images.githubusercontent.com/40616436/79884146-c021ee80-842f-11ea-9003-34fd0e4dd530.png)



*스레드의 상태*

![image](https://user-images.githubusercontent.com/40616436/79884326-ffe8d600-842f-11ea-8e3e-77a1eba21f2b.png)



*스레드 상태의 변화*

![image](https://user-images.githubusercontent.com/40616436/79884485-2dce1a80-8430-11ea-817d-94b9a91a8171.png)

1. 스레드를 생성하고 start()를 호출하면 바로 실행되지 않고 실행대기열에 저장되어 차례가 올 때까지 기다린다. 실행대기열은 queue 구조로 되어있다.
2. 실행 대기 상태에 있다가 자기 차례가 오면 실행 상태가 된다.
3. 주어진 실행시간이 다 되거나, yield()를 만나면 다시 실행대기상태가 되고, 다음 차례의 스레드가 실행상태가 된다.
4. 실행 중 suspend(), sleep(), wait(), join(), I/O block에 의해 일시정지상태가 될 수 있고, I/O block은 입출력 작업에서 발생하는 지연상태이다.
   - Ex. 사용자의 입력을 기다리는 경우로, 이런 경우 일시정지 상태에 있다가 사용자가 입력을 마치면 다시 실행대기상태가 된다.
5. 지정된 일시정지 시간이 다 되거나(time-out), notify(), resume(), interrupt()가 호출되면 일시정지 상태를 벗어나 다시 실행대기상태가 된다.
6. 실행을 모두 마치거나 stop()이 호출되면 스레드는 소멸한다.