## 스레드의 실행제어

- 스레드 프로그래밍이 어려운 이유는 동기화(synchronization)와 스케줄링(scheduling) 때문이다.

- 스레드와 멀티 스레드를 효율적으로 사용하기 위해서는 보다 정교한 스케줄링이 필요하며, 스케줄링을 잘 하기 위해서는 **스레드의 상태와 관련 메소드** 를 잘 알아야 한다.

  

*스레드 관련 메소드*

![image](https://user-images.githubusercontent.com/40616436/79884146-c021ee80-842f-11ea-9003-34fd0e4dd530.png)



*스레드의 상태*

![image](https://user-images.githubusercontent.com/40616436/79884326-ffe8d600-842f-11ea-8e3e-77a1eba21f2b.png)



*스레드 상태의 변화*

![image](https://user-images.githubusercontent.com/40616436/79884485-2dce1a80-8430-11ea-817d-94b9a91a8171.png)

1. 스레드를 생성하고 start()를 호출하면 바로 실행되지 않고 실행대기열에 저장되어 차례가 올 때까지 기다린다. 실행대기열은 queue 구조로 되어있다.
2. 실행 대기 상태에 있다가 자기 차례가 오면 실행 상태가 된다.
3. 주어진 실행시간이 다 되거나, yield()를 만나면 다시 실행대기상태가 되고, 다음 차례의 스레드가 실행상태가 된다.
4. 실행 중 suspend(), sleep(), wait(), join(), I/O block에 의해 일시정지상태가 될 수 있고, I/O block은 입출력 작업에서 발생하는 지연상태이다.
   - Ex. 사용자의 입력을 기다리는 경우로, 이런 경우 일시정지 상태에 있다가 사용자가 입력을 마치면 다시 실행대기상태가 된다.
5. 지정된 일시정지 시간이 다 되거나(time-out), notify(), resume(), interrupt()가 호출되면 일시정지 상태를 벗어나 다시 실행대기상태가 된다.
6. 실행을 모두 마치거나 stop()이 호출되면 스레드는 소멸한다.



**스레드 상태와 관련된 메소드를 하나씩 살펴보자**

**sleep(long millis) - 일정시간동안 스레드를 멈추게 한다.**

~~~java
public class SleepThread {
    public static void main(String [] args) {
        SleepThread_1 th1 = new SleepThread_1();
        SleepThread_2 th2 = new SleepThread_2();

        th1.start();
        th2.start();

        try {
            th1.sleep(2000);
        } catch (InterruptedException e) {

        }

        System.out.println("main 종료");
    }
}

class SleepThread_1 extends Thread {
    public void run() {
        for(int i = 0; i<300; i++) {
            System.out.print("-");
        }
        System.out.println("th_1 종료");
    }
}

class SleepThread_2 extends Thread {
    public void run() {
        for(int i = 0; i<300; i++) {
            System.out.print("|");
        }
        System.out.println("th_2 종료");
    }
}

~~~

![image](https://user-images.githubusercontent.com/40616436/79886378-bc906680-8433-11ea-9522-8f0f58e9c623.png)

- 위 결과를 보면 th1의 작업이 가장 먼저 종료되고 th2, main 순인 것을 확인할 수 있다.
- th1과 th2에 대해 start()를 호출하자마자 **th1.sleep(2000)**을 호출하여 th1이 2초 동안 작업을 멈추고 일시정지 상태에 있도록 하였으니 th1이 가장 늦게 종료되어야 하는데 제일 먼저 종료되었다.

*이유*

**sleep()**이 항상 현재 실행 중인 스레드에 대해 작동하기 때문에 th1.sleep(2000)과 같이 호출했어도 **실제로 영향을 받는 것은 main 메소드를 실행하는 main 스레드이다.**

그래서 sleep()은 static으로 선언되어 있으며 참조변수를 이용해 호출하기 보다는 Thread.sleep(2000);과 같이 사용해야한다.

