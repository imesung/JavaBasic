## 전략 패턴

전략 패턴은 **각각의 객체들이 할 수 있는 행위 대해 클래스(전략 클래스)를 생성**하고, **유사한 행위들을 캡슐화 하는 인터페이스를 정의**한다. 그 후 **객체의 행위를 동적으로 바꾸고 싶은 경우 직접 소스 수정을 하지 않고 전략만 바꿔**줌으로써 유연하게 확장하는 방법을 말한다.

쉽게 말해, 고양이의 행동을 살펴보자

- 점프
- 전진
- 후진

고양이는 움직일 수 있는데, 점프도 할 수 있고 전진, 후진도 할 수 있다.

~~~ java
//유사한 행위들 캡슐화
public interface CatMove{
  public void action();
}

//고양이 행위(전략 클래스)
class UpMove implements CarMove {
  @Override
  public void action() {
    sout("up");
  }
}

class DownMove implements CarMove {
  @Override
  public void action() {
    sout("down");
  }
}

class JumpMove implements CarMove {
  @Override
  public void action() {
    sout("jump");
  }
}

//고양이 클래스
public class Cat {
  private CatMove catMove;
  
  public Cat(CatMove catMove) {
    this.catMove = catMove;
  }
  
  public void move() {
    catMove.action();
  }
  
  public void setCatMove(CatMove catMove) {
    this.catMove = catMove;
  }
}

//Main
public static void main(String[] args) {
  Cat cat1 = new Cat(new UpMove());
  cat1.move();
  
  Cat cat2 = new Cat(new DownMove());
  cat2.move();
  
  Cat cat3 = new Cat(new JumpMove());
  cat3.move();
}
~~~

이 처럼 고양이의 행동이 변해도 기존 소스 수정없이 고양이의 행동을 변화시킬 수 있는 것이다. 

**추후 왼쪽으로 이동(LeftMove)이 추가되도 메인 소스에서만 추가하면 되는 장점이 나타나는 것이다.**



**전략 패턴의 장점**

- 코드 중복의 방지
- 런타임 시 타겟 메소드 변경
- 확장성 및 알고리즘 변경 용이



**전략 패턴의 다이어그램은 아래와 같다**

![image](https://user-images.githubusercontent.com/40616436/73272484-cbe18880-4225-11ea-93b8-061b9ab188fd.png)



**참고**

https://niceman.tistory.com/133





## 템플릿 메서드 패턴

템플릿 메서드 패턴은 하위 클래스에서 구현하거나 위임하는 데 사용한다.

즉, **공통으로 사용하는 알고리즘은 부모 클래스에 정의**하고 **특정 부분에서 사용하는 알고리즘은 하위 클래스에서 수행하도록 설계**한 것이다.

**템플릿 메서드의 장단점**

장점

- 코드 중복이 감소한다.
- 자식 클래스의 역할을 감소시키면서 핵심 로직 관리가 용이하다.
- 객체 추가 및 확장이 쉽게 가능하다.

단점

- 추상메소드가 너무 많아지면 클래스 관리가 복잡해진다.
- 추상클래스와 구현클래스간 복잡성이 증대한다.



![image](https://user-images.githubusercontent.com/40616436/73273487-655d6a00-4227-11ea-974d-618ebd2f8508.png)

buildWalls() 메소드와 buildPillars() 메소드는 **하위 클래스에서 입맛에 맞게 구현할 수 있고, 공통적으로 필요한 메소드는 상위 메소드를 사용할 수 있는 것이다.**



**참고**

https://niceman.tistory.com/142