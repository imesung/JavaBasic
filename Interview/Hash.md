### Hash

### Hash의 개요

ArrayList 대신 LinkedList를 사용하면 삽입, 삭제를 진행할 때 인근 노드의 참조값만 수정을 하면 되므로 빠른 처리가 가능했다.

그러나, LinkedList에서 데이터 검색을 진행할 때는 해당 노드를 찾기 위해 처음부터 끝까지 순회 검색을 해야한다는 단점이 발생하는데, 

이러한 LinkedList의 한계를 극복하기 위해 **Hash**가 등장했다.



### Hash의 기본개념

Hash는 내부적으로 **배열**을 사용하여 데이터를 저장하여 **빠른 검색 속도**를 갖는다.

Hash는 데이터 삽입, 삭제시 기존 데이터를 밀거나 채우는 작업을 안 하고 **특별한 알고리즘**을 활용하여 데이터와 연관된 고유 숫자를 만들어 낸뒤 **인덱스**로 사용한다.

이 때 Hash가 내부적으로 사용하는 배열을 **Hash Table**이라고 하며 크기에 따라 성능차이가 난다.



### Hash 메소드(Hash 함수)

Hash는 Hash Table을 이용하여 데이터를 저장한다.

그리고 해당 배열에서 삽입, 삭제를 진행할 때 특별한 알고리즘을 이용하여 데이터의 고유한 숫자를 만들어 인덱스로 사용하는데, 이 **알고리즘을 구현한 메소드를 Hash Method**라고 한다.



**Hash Method 구현 방법(나머지 연산자)**

- 데이터의 고유한 **hashCode를 구한 뒤 hashCode를 테이블의 크기로 나머지 연산**을 하고 그 결과를 해당 데이터의 인덱스로 사용하는 것이다.
  - 예를 들어, "a", "b", "c"의 hashCode가 각각 97, 98, 99라고 하고 HashTable의 크기가 10이라고 했을 때 테이블에 저장되는 인덱스 값을 구해보자
    - 97%10 = 7
    - 98%10 = 8
    - 99%10 = 9
  - 즉,  Hash Table의 인덱스 7에는 "a"를 저장, 8에는 "b", 9에는 "c"를 저장하는 방식이다.
  - 나중에 검색을 진행할 때는 hashCode의 값과 HashTable 크기를 이용한 나머지 연산으로 인덱스를 바로 참조하여 데이터를 꺼내는 것이다.
- **하지만, 인덱스가 중복으로 나타날 경우엔 어떻게 처리하는 가?**
  - 예를 들어, 4, 8, 12, 16 이라는 hashCode를 가진 데이터가 있다고 가정하고, Hash Table의 크기는 8이다.
    - 4%8 = 4
    - 8%8 = 0
    - 12%8 = 4
    - 16%8 = 0
  - 도출되는 인덱스로 데이터를 저장하려고 했으나 해당 인덱스에는 데이터가 존재하므로 이런 현상은 **collision(충돌)**이라고 하며, 이런 충돌을 최대한 방지하기 위해서는 **나머지 연산의 값이 최대한 중복되지 않도록 테이블의 크기를 소수로 만든다**
    - Hash Table 크기를 8이 아닌 **11**(소수)로 변경한다.
      - 4%11 = 4
      - 8%11 = 8
      - 12%11 = 1
      - 16%11 = 5
  - 하지만 이 방법도 충돌이 줄이기 위한 방법이지 해결을 위한 방법이 아니다.



### hashCode Index의 충돌 해결방법

충돌 해결방법으로는 두가지가 있다. **개방주소법**과 **분리연결법**



**분리연결법**

분리연결법은 Hash Table에 **LinkedList에서 사용하는 Node 객체를 저장**하는 것이다.

즉, Hash Table의 셀마다 LinkedLIst를 하나씩 저장하고 충돌이 발생할 때마다 데이터를 LinkedList의 다음 노드로 추가하는 것이다.

이후 데이터 검색 시 Hash Table 인덱스를 찾은 후 연결된 LinkedList를 순차적으로 탐색하는 것이다.

![image](https://user-images.githubusercontent.com/40616436/73239309-12f85b00-41df-11ea-81a8-7b251c4a68f1.png)

**개방주소법**

분리연결법과(배열과 LinkedList)는 다르게 배열만 사용하고 인덱스가 겹칠 경우에는 해당 인덱스의 옆 인덱스에 저장하는 방식이다..







**참고**

https://hyeonstorage.tistory.com/265