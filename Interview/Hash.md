### Hash

### Hash의 개요

ArrayList 대신 LinkedList를 사용하면 삽입, 삭제를 진행할 때 인근 노드의 참조값만 수정을 하면 되므로 빠른 처리가 가능했다.

그러나, LinkedList에서 데이터 검색을 진행할 때는 해당 노드를 찾기 위해 처음부터 끝까지 순회 검색을 해야한다는 단점이 발생하는데, 

이러한 LinkedList의 한계를 극복하기 위해 **Hash**가 등장했다.



### Hash의 기본개념

Hash는 내부적으로 **배열**을 사용하여 데이터를 저장하여 **빠른 검색 속도**를 갖는다.

Hash는 데이터 삽입, 삭제시 기존 데이터를 밀거나 채우는 작업을 안 하고 **특별한 알고리즘**을 활용하여 데이터와 연관된 고유 숫자를 만들어 낸뒤 **인덱스**로 사용한다.

이 때 Hash가 내부적으로 사용하는 배열을 **Hash Table(배열)**이라고 하며 크기에 따라 성능차이가 난다.



### **해시 분포와 해시 충돌**

동일하지 않은 객체 X와 Y가 있는데, X.equals(Y)가 false일 때 X.hashCode() == Y.hashCode()도 false면 이 때 사용하는 해시 함수는 **완전 해시 함수**라고 한다.

Boolean같이 서로 구별하는 객체의 종류가 적거나(true아니면 false), Integer, Long, Double 같은 Number 객체는 **객체가 나타내려는 값 자체를 해시 값으로 사용할 수 있기 때문이 이 또한 완전 해시 함수 대상으로 삼을 수 있다.**

String과 POJO에 대하여 완전한 해시 함수를 제작하는 것은 불가능하다.

~~~reStructuredText
[여기서 잠깐!]
POJO는 getter setter를 가진 평범한 객체를 말하는 것이다.
여기서 평범한 객체는, 
	- 클래스의 상속을 강제하지 않는다.
	- 인터페이스의 구현을 강제하지 않는다.
	- 애노테이션의 사용을 강제하지 않는다.
~~~

하지만 정작 중요한 것은, 완전한 해시 함수가 있더라도 그것을 HashMap에서는 바로 사용할 수 있는 것은 아니다.

HashMap에서 사용하는 hashCode()의 반환값은 int타입인데 int 타입은 32비트 크기를 가지고 있다. 즉, 이 크기로는 완전한 해시 함수를 만들 수 없는 것이다.

그 이유는 모든 HashMap 객체에서 순회를 할 시 O(1)를 보장하게 하려면 원소가 2^32인 배열을 모든 HashMap이 가지고 있어야 한다. 그로 인해 HashMap을 비롯한 해시 함수를 이용하는 구현체에서는 메모리 절약을 위해 실제 해시 함수의 표현 정수 범위보다 작은 M개의 원소가 있는 배열(Hash Table)만 사용한다.

따라서 다음과 같이 객체에 대한 해시 코드의 나머지 값을 이용해서 해시 버킷 인덱스를 구성한다.

**해시 버킷 : 해시가 저장되어 있는 슬롯을 말한다.**

~~~java
int index = X.hashCode() & M;
~~~

이 코드와 같은 방식을 사용하면 서로 다른 객체가 1/M 확률로 같은 해시 버킷을 사용하게 된다. 이것이 해시 충돌이다.

이렇게 해시가 충돌될 때 해결하는 방법 두 가지가 있는데, 분리연결법(SeparateChaining)과 개방연결법(Open Adressing)이다.



**Hash 내부 구조 및 해시 버킷의 구조를 살펴보자**

![image](https://user-images.githubusercontent.com/40616436/73587456-6af4d180-44ff-11ea-8912-8436826e49ac.png)



다음 해시 버킷 인덱스를 구하는 방법과 해시 충돌 해결의 예를 살펴보자

## Hash Method 구현 방법 및 해시 충돌 해결 예



### Hash Method 구현 방법

- 데이터의 고유한 **hashCode를 구한 뒤 hashCode를 테이블의 크기로 나머지 연산**을 하고 그 결과를 해당 데이터의 인덱스로 사용하는 것이다.
  - 예를 들어, "a", "b", "c"의 hashCode가 각각 97, 98, 99라고 하고 HashTable의 크기가 10이라고 했을 때 테이블에 저장되는 인덱스 값을 구해보자
    - 97%10 = 7
    - 98%10 = 8
    - 99%10 = 9
  - 즉,  Hash Table의 인덱스 7에는 "a"를 저장, 8에는 "b", 9에는 "c"를 저장하는 방식이다.
  - 나중에 검색을 진행할 때는 hashCode의 값과 HashTable 크기를 이용한 나머지 연산으로 인덱스를 바로 참조하여 데이터를 꺼내는 것이다.
- **하지만, 인덱스가 중복으로 나타날 경우엔 어떻게 처리하는 가?**
  - 예를 들어, 4, 8, 12, 16 이라는 hashCode를 가진 데이터가 있다고 가정하고, Hash Table의 크기는 8이다.
    - 4%8 = 4
    - 8%8 = 0
    - 12%8 = 4
    - 16%8 = 0
  - 도출되는 인덱스로 데이터를 저장하려고 했으나 해당 인덱스에는 데이터가 존재하므로 이런 현상은 **collision(충돌)**이라고 하며, 이런 충돌을 최대한 방지하기 위해서는 **나머지 연산의 값이 최대한 중복되지 않도록 테이블의 크기를 소수로 만든다**
    - Hash Table 크기를 8이 아닌 **11**(소수)로 변경한다.
      - 4%11 = 4
      - 8%11 = 8
      - 12%11 = 1
      - 16%11 = 5
  - 하지만 이 방법도 충돌이 줄이기 위한 방법이지 해결을 위한 방법이 아니다.



### hashCode Index의 충돌 해결방법

충돌 해결방법으로는 두가지가 있다. **개방주소법**과 **분리연결법**



**분리연결법**

분리연결법은 Hash Table에 **LinkedList에서 사용하는 Node 객체를 저장**하는 것이다.

즉, Hash Table의 셀마다 LinkedLIst를 하나씩 저장하고 충돌이 발생할 때마다 데이터를 LinkedList의 다음 노드로 추가하는 것이다.

이후 데이터 검색 시 Hash Table 인덱스를 찾은 후 연결된 LinkedList를 순차적으로 탐색하는 것이다.

**결과적으로, 데이터를 삽입하려는 해시 버킷이 이미 사용 중이라면 다른 해시 버킷에 해당 데이터를 삽입하는 방식이다.**

![image](https://user-images.githubusercontent.com/40616436/73239309-12f85b00-41df-11ea-81a8-7b251c4a68f1.png)

**개방주소법**

분리연결법과(배열과 LinkedList)는 다르게 배열만 사용하고 인덱스가 겹칠 경우에는 해당 인덱스의 옆 인덱스에 저장하는 방식이다..(일반 배열 형태이다.)



**해시 충돌 장단점**

개방주소법은 연속된 공간에 데이터를 저장하기 때문에 캐시효율이 높다.

데이터의 개수가 충분히 적다면 개방주소법이 성능이 더 좋다.

하지만 배열의 크기가 커질수록(M값이 커질수록) 캐시 효율이라는 개방주소법의 장점은 사라진다.

- 배열이 커짐에 따라 캐시 적중률이 낮아지기 때문이다.







**참고**

https://hyeonstorage.tistory.com/265