## 전략 패턴

전략 패턴은 **각각의 객체들이 할 수 있는 행위 대해 클래스(전략 클래스)를 생성**하고, **유사한 행위들을 캡슐화 하는 인터페이스를 정의**한다. 그 후 **객체의 행위를 동적으로 바꾸고 싶은 경우 직접 소스 수정을 하지 않고 전략만 바꿔**줌으로써 유연하게 확장하는 방법을 말한다.

쉽게 말해, 고양이의 행동을 살펴보자

- 점프
- 전진
- 후진

고양이는 움직일 수 있는데, 점프도 할 수 있고 전진, 후진도 할 수 있다.

~~~ java
//유사한 행위들 캡슐화
public interface CatMove{
  public void action();
}

//고양이 행위(전략 클래스)
class UpMove implements CarMove {
  @Override
  public void action() {
    sout("up");
  }
}

class DownMove implements CarMove {
  @Override
  public void action() {
    sout("down");
  }
}

class JumpMove implements CarMove {
  @Override
  public void action() {
    sout("jump");
  }
}

//고양이 클래스
public class Cat {
  private CatMove catMove;
  
  public Cat(CatMove catMove) {
    this.catMove = catMove;
  }
  
  public void move() {
    catMove.action();
  }
  
  public void setCatMove(CatMove catMove) {
    this.catMove = catMove;
  }
}

//Main
public static void main(String[] args) {
  Cat cat1 = new Cat(new UpMove());
  cat1.move();
  
  Cat cat2 = new Cat(new DownMove());
  cat2.move();
  
  Cat cat3 = new Cat(new JumpMove());
  cat3.move();
}
~~~

이 처럼 고양이의 행동이 변해도 기존 소스 수정없이 고양이의 행동을 변화시킬 수 있는 것이다. 

**추후 왼쪽으로 이동(LeftMove)이 추가되도 메인 소스에서만 추가하면 되는 장점이 나타나는 것이다.**



**전략 패턴의 장점**

- 코드 중복의 방지
- 런타임 시 타겟 메소드 변경
- 확장성 및 알고리즘 변경 용이



**전략 패턴의 다이어그램은 아래와 같다**

![image](https://user-images.githubusercontent.com/40616436/73272484-cbe18880-4225-11ea-93b8-061b9ab188fd.png)



**참고**

https://niceman.tistory.com/133