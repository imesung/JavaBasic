## HTTP 1.0 vs HTTP 1.1

### HTTP 1.0

HTTP 1.0은 단순히 open/operation/close 방식을 취하고 있는 단순한 구조이다.

***TCP Connection당 하나의 URL만 fetch하며, 매번 request/response가 끝나면 연결이 끊기므로 필요할 때마다 다시 연결해야한다는 단점이 있어 속도가 현저히 느리다. URL 크기가 작고 한번에 가져올 수 있는 데이터의 양이 제한되어 있다.***

이 처럼, **반복되는 disconnect 현상으로 인해 한 서버에 계속해서 접속을 시도하게 되면 과부하**가 걸리고 성능이 떨어지게 되는데 이런 문제를 해결하기 위해서 등장한 것이 **HTTP 1.1**이다.



### HTTP 1.1

HTTP의 인터넷에서 impact를 줄이고 **cache를 두어 인터넷 프로토콜 수행이 빠르게 될 수 있도록 성능을 향상**하고 있는 것이다.

**HTTP 1.1은 기본적으로 하나의 연결당 하나의 요청과 응답을 처리도록 설계되어 있고, multiple request 처리가 가능하여 아래 그림과 같이 한번의 연결로 여러번 reqeust가 가능하다. 단, request후 response가 와야지만 다음 request가 가능하다.**

<img src="https://user-images.githubusercontent.com/40616436/98549643-6fe08000-22de-11eb-839c-1f497c552637.png" alt="image" style="zoom:50%;" />

---

## HTTP1.1 vs HTTP 2

### HTTP 1.1

**HTTP 1.1은 기본적으로 하나의 연결당 하나의 요청과 응답을 처리하기 때문에 동시 전송 문제와 다수의 리소스를 처리하는 것에 대해 속도와 성능 이슈를 가지고 있다.****

HTTP 1.1의 대표적인 문제점은 HOL Blocking, RTT 증가, 헤비한 Header를 가지고 있다.

**HOL(Head Of Line) Blocking - 특정 응답 지연**

- ***하나의 응답이 지연될 시 해당 응답이 완료될 때까지 다음 요청은 무한 대기 상태이다.***

**RTT(Round Trip Time) 증가**

- ***하나의 Connection 당 하나의 요청을 처리하므로 요청별로 Connection을 만들어야 한다.***
- 이로 인해, 3-way HandShake가 반복적으로 일어나게 되며 불필요한 RTT 증가와 네트워크 지연을 초래하게 된다.

**헤비한 Header 구조**

- HTTP 1.1 헤더에는 많은 메타 정보들이 저장되는데, 사용자가 방문한 웹페이지는 **다수의 HTTP 요청**이 발생하게 된다.
- 이런 경우, 매 요청마다 **중복된 헤더 값을 전송**하게 되고, 해당 도메인에 설정된 **cookie 정보도 매 요청 시 헤더에 포함**되므로 **전송하려는 값보다 헤더 값이 더 클 수 있다.**



### HTTP 2.0

HTTP 2.0은 Multiplexed Streams, Stream Prioritization, Server Push, Header Compression을 사용하여 성능을 향상시켰다.

**Multiplexed Streams**

- ***한 커넥션에 여러 개의 메시지를 주고 받을 수 있다.***

**Stream Prioritization**

- ***요청 리소스간의 의존관계(우선순위)를 설정할 수 있다.***
- Ex. 클라이언트가 요청한 HTML 문서에 CSS 파일 1개와 IMAGE 파일 2개가 존재하는데, 만약 IMAGE 파일보다 CSS 파일의 수신이 늦어지는 경우 브라우저 렌더링이 늦어질 수가 있는데, 이 경우 리소스간의 우선순위를 정함으로써 해결이 가능하다.

**Server Push**

- ***서버는 클라이언트의 요청에 대해 요청하지 않은 리소스를 마음대로 보낼 수 있다. 클라이언트의 요청을 최소화할 수 있다.***
- 클라이언트가 HTML 문서를 요청할 시 해당 HTML에 여러 개의 리소스(CSS, IMAGE)가 포함될 경우 HTTP 1.1과 HTTP 2.0의 차이가 존재한다.
  - HTTP 1.1 : HTML 문서를 해석하기 위해 필요한 리소스를 재요청할 수 있다.
  - HTTP 2.0 : HTML 문서를 해석하기 위한 리소스를 재요청하지 않고 Server Push 기법을 활용하여 한방에 해석이 가능하다.

**Header Compression**

- Header 정보를 **HPACK 압축 방식**을 이용하여 압축 후 전송한다.
- Ex. 클라이언트가 두 번의 요청을 보낸다고 가정할 때 HTTP 1.1과 HTTP 2.0의 차이를 살펴보자.
  - HTTP 1.1 : 두 개의 요청 Header에 중복값이 존재하더라도 그냥 중복 전송을 진행한다.
  - HTTP 2.0 : **Header에 중복 값이 존재**할 시 **static/Dynamic Header Table 개념**을 이용해 중복 Header를 검출 후 중복된 Header는 index 값만 전송하고, **중복되지 않는 정보 값**은 **Huffman Encoding 기법**으로 인코딩하여 전송하는 것이다.

<img src="https://user-images.githubusercontent.com/40616436/98551542-c484fa80-22e0-11eb-9ee2-c76d410d4a1c.png" alt="image" style="zoom:50%;" />

### 쉬운 그림으로 보는 HTTP 1.1과 HTTP 2.0

<img src="https://user-images.githubusercontent.com/40616436/98551640-e41c2300-22e0-11eb-808c-fb594a1d3957.png" alt="image" style="zoom:50%;" />

**HTTP 1.x 버전 대신 HTTP 2.0을 사용해도 응답속도가 15%~50% 정도 향상된다.**

---

### SSL 인증서(대칭키와 공개키)

SSL 인증서는 클라이언트와 서버간의 통신을 제 3자가 보증해주는 전자화된 문서이다.

**SSL 인증서의 장점**

- 클라이언트와 서버간의 통신 내용이 공격자에게 노출되는 것을 막을 수 있다. -> **암호화가 필요**
- 클라이언트가 접속하려는 서버가 신뢰할 수 있는 서버인지를 판단할 수 있다.
- 해커가 통신 내용의 악의적인 변경을 막을 수 있다.

**대칭키**

***대칭키란, 전송하고자 하는 데이터를 암호화할 때 필요한 Key 값으로서, 수신받는 쪽도 같은 Key로만 복호화가 가능하다.***

- 하지만 대칭키 방식으로 암호화된 데이터를 주고 받을 때, 경유지가 많고 키값도 공유해야하는 상황이 발생했을 때는 각 경유지마다 키값이 공개되어 데이터를 암호화한 의미가 사라진다는 **단점**이 나타난다.

**공개키(비대칭키)**

***공개키란, 총 2개의 Key가 존재하는 것으로서 약속된 다른 Key로만 암호화하거나 복화하는 것을 말한다.*** 

예를 들어, A라는 공개키와 B라는 비밀키가 있을 때 A라는 공개키로 암호화를 했으면 B라는 비밀키로 복호화할 수 있고, B라는 공개키로 암호화 했을 때는 A비밀키로 복호화할 수 있다. 즉, 공개키에 해당하는 비밀키를 가지고 있어야지 암복호화가 가능하다는 것이다.

- 암호화된 데이터를 주고 받을 때 경유지가 많고 키값을 공유해야 하더라도, 공유한 키값으로는 암호화된 데이터를 복호화할 수 없으므로 **대칭키의 단점을 해결** 할 수 있다.

*그럼 반대는 안 되는가?*

반대 방법은 **인증**을 할 때 많이 사용된다. 만약 개인이 가지고 있는 비밀키로 암호화한 데이터(인증에 필요한 데이터)를 어떤 서비스에 인증을 할 때, 해당 서비스는 자신이 가지고 있는 공개키로 데이터가 복호화 된다면 인증에 성공을 시키는 것이다.





