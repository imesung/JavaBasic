## 브릿지 패턴

### 개요

브릿지 패턴의 내용을 살펴보고 어댑터 패턴 그리고 전략 패턴이 어떤 면에서 차이가 나는지, 그리고 브릿지 패턴을 왜 사용하는 지의 순서로 진행하겠습니다.

---

### 정의

브릿지 패턴을 간단하게 풀어서 말하면 기능 클래스의 계층과 구현 클래스의 계층을 분리하고 이들을 마치 다리로 연결시켜 놓은 것을 말합니다.

기능의 계층과 구현의 계층을 분리하여 각각의 클래스 계층을 독립적으로 확장하기 위한 목적을 말합니다. 쉽게 말하면 구현을 추가하고 싶을 때는 구현의 클래스 계층에 추가하면 되고, 이 때 기능의 클래스 계층은 전혀 수정할 필요가 없다는 것입니다.

---

### **예시의 구조**

저희가 강의를 통해 살펴본 구조를 보면 이 구조가 되고, 예제를 구조로 확인해보면 제가 그린거와 같이 나타날 것입니다.

구조에 대해서 간략히 설명드리면 왼쪽은 구현의 클래스 계층이고, 오른쪽은 기능의 클래스 계층입니다.

---

### 기능의 클래스 계층을 소스로 살펴보자.

MorseCode 클래스의 경우는 MorseCodeFunction이라는 클래스를 포함하고 있고, 기본적인 기능들을 정의하고 있습니다.

그런데 여기서 MorseCodeFunction은 구현의 클래스 계층인데 왜 기능의 클래스 계층에서 합성관계를 가지고 있는지 의아할 수 있습니다. 얘가 바로 다리 역할을 객체입니다.

////////////////////////////////////////

**합성 관계 관련 객체지향 설명 필요**

객체지향적으로 보면, 상속 대신 합성을 사용해야 하는 경우가 있습니다.

상속의 경우 상위 클래스의 기능들을 하위 클래스에서 사용할 수 있기 때문에 캡슐화를 위반하고 있고, 상위 클래스와 하위 클래스의 관계를 컴파일 시점에 결정하여 설계 자체에 유연하지 못한다라는 단점을 가지고 있습니다. 

>  (A 클래스를 생성하는 파라미터에 두개의 하위 클래스 중 하나를 가지면서 생성하였고, 추 후에 클라이언트에 의해 두개의 하위 클래스 중 다른 하나의 하위 클래스로 변경하고 싶다면, 이 방법은 A클래스를 다시 생성하는 수 밖에 없다. 하지만 합성을 사용하면, A 클래스가 합성한 클래스를 이용한 메소드로 변경이 이루어질 수 있다. )

하지만 합성을 사용하게 되면, 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하므로 구현을 효과적으로 캡슐화할 수 있고, 의존하고 있는 인스턴스의 교체가 비교적 쉬워 설계도 유연하게 만들 수 있다는 점이 있습니다.

여기서 중요한 것은, 상속을 사용하면 안 좋다라는 것은 아니고, 코드를 재사용하는 측면에서 상속보단 합성을 사용하는 것이 옳다라는 것입니다. 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 조합해서 사용할 수밖에 없습니다.

////////////////////////////////////////

그리고 이제 PrintMorseCode는 MorseCode를 상속받아 모스 부호의 기능들을 정의하고 있습니다.

---

### 구현의 클래스 계층을 소스로 살펴보자.

MorseCodeFunction을 인터페이스로 정의하고 DefaultMCF는 해당 인터페이스를 implements하여 추상 메소드를 구현하게 됩니다.

---

### Main

메인 함수를 살펴보면, 구현 부분은 DefaultMCF가 구현한 것을 사용하고, 기능 부분은 PrintMorseCode가 정의한 기능을 사용하여 blue의 문자를 모스부호로 나타내고 있는 것을 볼 수 있습니다.

---

### **음성 모스 부호 추가될 시**

강의에서도 살펴본 바와 같이 문자 모스 부호가 아닌 음성 모스 부호로 변경이 이루어지면, 구현 클래스의 계층에 SoundMCF 클래스만 정의하면 원활하게 결과값을 나타낼 수 있습니다.

---

### **정리**

브릿지 패턴은 구현이 추가되면 구현의 클래스 계층만 변경하면 되고, 기능이 추가되면 기능의 클래스 계층만 변경하면 되는 것입니다. 가장 중요한 것은 각자 변경이 이루어져도 상대 계층에게는 전혀 영향을 안 준다는 것이 키포인트입니다.

---

### **어댑터 패턴 vs 브릿지 패턴**

두 패턴의 가장 큰 차이는 목적이 무엇인가 입니다.

어댑터 패턴의 목적은 두 인터페이스 간의 불일치를 해결하려는 것이고, 브릿지 패턴의 목적은 추상화 개념과 구현을 따로 만들고 이들을 연결시켜 주려고 하는 것이 주 목적입니다.

어댑터 패턴의 경우 두 클래스간의 다른 부분을 미리 예측하지 못하고 **설계 후** 개발을 진행했을 때 필요한 패턴이고, 

브릿지 패턴은 **설계 중**에 추상화를 구현한 방법이 여러가지가 있고, 각 구현 객체들의 증가와 확장성을 파악한 상태에서 적용하는 패턴입니다.

---

### **브릿지 패턴 vs 전략 패턴**

두 패턴의 가장 큰 차이는 의도가 다른 것입니다.

브릿지 패턴의 경우 구현과 기능을 분리시켜 계층간의 결합도를 낮춘 것이고,

전략 패턴의 경우 계층간의 결합도는 신경쓰지 않고, 반복적으로 변경되거나 추가되는 부분을 추상화하여 변경 가능하도록 한 패턴입니다.

---

### 브릿지 패턴은 왜 사용하는가?

Before : 브릿지 패턴을 사용하기 전에는 인터페이스와 내부 구현으로 한 개의 클래스를 정의하였습니다.

하지만 브릿지 패턴을 적용함으로써 구현 부분과 인터페이스 부분을 분리한 것을 볼 수 있습니다.

변경에 대한 이점은 브릿지 패턴에서 설명했듯이 구현 부분이 추가되면 구현부만 수정하면 되므로 변경 및 추가가 용이하다는 것입니다.

또한, 보안에 대한 이점은 외부에 노출되는 곳은 인터페이스 즉, 기능 부분이므로 상세한 구현 부분은 감출 수가 있어 보안도 뛰어날 수 있다는 것입니다.

마지막으로, 추가에 대한 이점은 브릿지 패턴을 사용하기 전에 구현 부분이 N개가 되고 외부에서 상황에 따라 사용하는 구현이 달라지면 외부에서는 switch 혹은 if/else문을 사용해야 합니다.

하지만, 브릿지 패턴을 사용하면 외부에서는 구현의 최상위 계층만을 바라보고 있으니, 하위 계층의 추가 혹은 수정은 전혀 신경쓸 필요가 없게 되는 것입니다.

[https://kimsunzun.tistory.com/m/entry/Bridge-%ED%8C%A8%ED%84%B4](https://kimsunzun.tistory.com/m/entry/Bridge-패턴)