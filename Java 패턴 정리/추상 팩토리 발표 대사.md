### 추상 팩토리 패턴

### **개요 설명**

추상 팩토리 패턴에 들어가기 전에 템플릿 메소드 패턴과 팩토리 메소드 패턴을 간단하게 구현해보고, 왜 추상 팩토리 패턴이 필요한지를 살펴보겠습니다.

---

### **정의**

좀 더 쉽게 말해서, 추상 팩토리 패턴은 서로 관련이 있는 객체들을 묶어서 팩토리 클래스로 만들고, 해당 팩토리를 조건에 따라 생성하는 또 다른 팩토리를 만들어서 객체를 생성하는 패턴입니다.

---

### **예시를 살펴보자**

해당 예시는 엘리베이터를 만드는데 필요한 부품들이 업체별로 나누어져있을 때, 부품들을 가져와 사용하는 예시입니다.

이 예시를 **팩토리 메소드 패턴**을 이용하여 구현해보겠습니다.

구조를 간략히 설명해드리면, 추상클래스로 정의한 Motor의 하위 클래스로 각 업체별 Motor 클래스를 정의하였고, Door 클래스 또한 추상클래스로 정의한 후 하위 클래스에 각 업체별 Door 클래스를 정의하였습니다. 그리고 Motor 클래스에 의해 엘리베이터가 움직이기 전에는 Door가 닫혀있어야 되므로 Motor와 Door를 합성관계로 둔 것입니다.

---

### **Motor의 move()와 Door의 open(), close()**

Motor와 Door의 핵심 메소드들을 살펴보겠습니다.
Motor 클래스의 핵심 기능은 move() 메소드이고 보시는 바와 같이 1번 부터 4번까지의 기능이 있는데 3번의 기능만 제조 업체에 따라 달라지는 것을 확인할 수 있고, Door 클래스 또한 1번부터 3번까지는 동일한데 2번의 기능만 다른 것을 확인할 수 있습니다. 
그리고 이 두 메소드들은 **템플릿 메소드 패턴**을 통해서 move() 메소드와 open과 close 메소드를 구현할 수 있습니다.

---

### **Door 소스를 구현해보겠습니다.**

DoorStatus는 Enum 클래스로 정의해두고 추상 클래스인 Door는 doclose() 메소드와 doopen() 메소드만 추상 메소드로 선언하고 나머지 메소드들은 직접 구현을 하였습니다.  

그리고 각 업체별 Door 클래스는 Door 추상 클래스를 상속받아 업체별 기능을 구현하는 것을 볼 수 있습니다.

Motor 또한 거의 동일하므로 생략하겠습니다.

---

### **팩토리 메소드 패턴**

이제 Door 그리고 Motor 클래스와 관련된 구현은 모두 끝냈으니, Motor와 Door를 활용하여 엘리베이터가 작동할 수 있도록 구현을 하겠습니다.
**이 부분에서는 팩토리 메소드 패턴을 이용하여 구현해볼 수 있습니다.**

여기서 팩토리 메소드 패턴에 대해서 간략히 살펴보면, **팩토리 메소드 패턴은 객체 생성 처리를 서브 클래스로 분리하고 캡슐화함으로써 객체 생성의 변화에 대비할 수 있다는 것입니다.**

그럼 이제 업체별 Motor와 Door를 생성하는 팩토리 클래스를 만들어 보겠습니다.

**외부에서 받아온 VendorID 값에 따라 객체생성하는 것 설명**
모터 팩토리 클래스를 만들어 놓고, 외부에서 들어오는 밴더 아이디값에 따라 각 업체별 모터 클래스를 생성하는 것을 볼 수 있습니다.
도어 팩토리 클래스 또한 모터 팩토리 클래스와 동일하게 구현된 것을 볼 수 있습니다.

---

### Main

**그럼 이제 Main 에서는 각 팩토리 클래스의 메소드를 호출하여 각 업체별 Motor와 Door 객체를 만들 수 있는 것을 볼 수 있습니다.**

---

### **팩토리 메소드 문제점**

여기까지가 팩토리 메소드 패턴을 구현한 것이고, 팩토리 메소드 패턴으로 구현했을 때, 과연 베스트일까 라는 생각을 해볼 수 있습니다..

팩토리 메소드 패턴을 자세히 살펴보면, 총 두가지 문제점이 보이는데요.

**첫번째는,**  다른 부품으로 엘리베이터를 구동하자, 라는 요구사항이 나타나면 LGMotor와 LGDoor가 아닌 다른 부품으로 바꿔야하므로 보시는 소스처럼 LGMotor와 LGDoor를 그대로 변경하는 중복 코드가 발생할 수 있습니다. 
현재는 2개의 부품만 있지만, 추 후에는 10개에서 20개의 부품이 생긴다면 더욱 비효율적인 코드가 될 것이고 함수의 길이도 매우 길어지게 될 것입니다

**두번째는,** . 그리고 LG, 현대 말고 삼성의 부품이 추가된다면 Door를 상속받는 하위 클래스에 정의해야하고 Motor를 상속받는 하위 클래스에도 정의해야합니다. 즉, 각 팩토리 클래스를 일일히 찾아서 다른 업체의 부품들을 추가해야할 것입니다.

**결과적으로 이 같은 상황에서 팩토리 메소드 패턴을 이용했을 때는 코드 변경이 많이 이루어진다는 단점이 발생하게 됩니다. 
이런 문제를 해결하고자 등장한 것이 추상 팩토리 패턴입니다.**

---

### **추상 팩토리 패턴**

**추상 팩토리 패턴을 정의해보면, 여러 종류의 객체를 생성할 때 각 객체들이 관련이 있는 경우라면 관련된 객체들 끼리 일관성 있게 생성하는 팩토리 클래스를 만들어서 사용하는 것입니다.**

해당 구조에 대해 간략히 설명드리면, 팩토리 메소드 패턴 처럼 Motor 혹은 Door끼리 팩토리를 구성하는 것이 아니라 여기에서는 각 업체별로 팩토리 클래스를 구성하는 것입니다. 각 업체별 팩토리 클래스는 외부에 노출되는 엘리베이터 팩토리 클래스를 상속 받아 각 팩토리 클래스에서 구현하는 구조입니다.

---

### **추상 팩토리 패턴 소스 구성**

소스를 통해서 살펴보겠습니다.
소스에서 보시는 바와 같이 엘리베이터 팩토리 클래스는 추상 클래스로 구성되어 있고, 엘지엘리베이터 팩토리 클래스와 현대 엘리베이터 팩토리 클래스가 상속받아 구현을 하고 있습니다.

그리고 메인에서는 vendorName에 따라 각 업체별 엘리베이터가 생성되는 것을 볼 수 있습니다.

---

### **팩토리 메소드 패턴 문제점 해결**

이렇게 추상 팩토리 패턴으로 구성한 결과, 팩토리 메소드 패턴의 문제점을 해결한 것을 확인할 수 있습니다.

첫번째 문제점은 다른 업체로 변경하고자 할 때 중복된 코드가 발생한다는 문제였는데, 추상 팩토리 패턴으로 변경하면서 다른 업체로 변경을 하고 싶을 때는 메인에 분기 처리만 추가하여 변경할 수 있습니다.

두번째 문제점은 새로운 업체가 들어오면 각 팩토리에 부품을 추가하고 코드의 길이도 길어진다는 문제가 있었는데, 단순히 업체 팩토리만 추가하고, 메인에도 분기만 추가하여 변경할 수 있습니다.

**이 소스는 삼성이 추가되었을 때 추상 팩토리 패턴을 사용하면 추가되는 소스 입니다.**
근데 여기서 좀 변경해야 하지 않을까요?

---

### **진정한 추상 팩토리 패턴**

추상 팩토리 패턴의 정의를 다시 한번 살펴보면, 추상 팩토리 패턴은 서로 관련이 있는 객체들을 묶어서 하나의 팩토리 클래스로 만들고, **해당 팩토리를 조건에 따라 생성하는 또 다른 팩토리를 만들어서 객체를 생성하는 패턴입니다.**

다시 말하면, 추상 팩토리 패턴은 생성하는 부분이 팩토리 클래스로 구성되어야 하는데, 위 소스는 메인 함수에 떡하니 업체별 엘리베이터 팩토리들을 생성하고 있다는 것입니다.

그래서 업체별에 따라 엘리베이터 팩토리를 생성하는 엘리베이터 팩토리 팩토리 클래스를 만들고 getFactory 메소드의 인자로 벤더 아이디를 받아와 구분에 따라 업체 엘리베이터 팩토리를 생성하도록 한것입니다.

---

### **업체별 엘리베이터를 만들 때 싱글톤**

그리고 업체별 엘리베이터 팩토리를 만들 때는 하나의 객체만 생성하면 된다고 판단하여 이 부분에서는 전에 배운 레이지 홀더 싱글톤 패턴을 사용해보았습니다.

---

### **진정한 추상 팩토리 패턴 메인**

이제 다시 메인을 살펴보면 업체별 엘리베이터 팩토리가 생성되는 대신 구분에 따라 밴더 아이디에 값을 주고 엘리베이터 팩토리 팩토리 클래스에 밴더 아이디를 인자로 넘겨주는 것을 확인할 수 있습니다.

---

### **진정한 추상 팩토리 패턴 구조**

해당 그림은 진정한 추상 팩토리 패턴의 구조를 표현한 것입니다.

결론을 도출해 보면, 추상 팩토리 패턴을 공부해봤을 때 템플릿 패턴에서 팩토리 메소드 패턴, 팩토리 메소드 패턴에서 추상 팩토리 패턴으로 변화된 것은 객체지향설계에서 중요한 **낮은 결합도**를 위한 결과물인 것으로 보입니다.

