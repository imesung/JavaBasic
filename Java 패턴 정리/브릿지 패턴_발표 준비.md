## 브릿지 패턴

브릿지 패턴을 간단하게 풀어서 말하면, 기능 클래스의 계층과 구현 클래스의 계층을 다리로 연결 시켜 놓는다라는 말이다.

즉, 기능의 계층과 구현의 계층을 분리하여 각각의 클래스 계층을 독립적으로 확장하기 위함이 목적이다. 다시 말해 기능을 추가하고 싶으면 기능의 클래스 계층에 추가하면 된다 그리고 이때 구현의 클래스 계층은 수정할 필요가 전혀 없다는 것이다.

하지만 브릿지 패턴은 잘 사용하지 않고, 어댑터 패턴과 매우 비슷하다는 것을 알고 있어야 한다.

***어댑터 패턴과 어떤 면이 비슷?***

---

그럼 이제 설계를 통해 살펴보자.

<img src="https://user-images.githubusercontent.com/40616436/82153283-75b25700-98a1-11ea-89b2-cbcce973dffc.png" alt="image" style="zoom:50%;" />

왼쪽은 구현의 클래스 계층이고, 오른쪽은 기능의 클래스 계층으로 보면 된다. 우리의 실습 예제를 살펴보면,

<img src="https://user-images.githubusercontent.com/40616436/82831877-8b083080-9ef4-11ea-852c-95b67fa982f1.png" alt="image" style="zoom:50%;" />

위와 같은 구조가 될 것이다.

---

먼저 기능의 클래스 계층을 소스로 살펴보자.

~~~java
public class MorseCode {
  //MorseCodeFunction은 MorseCode 구현을 나타내는 인스턴스이다.
  //기능 클래스 계층에서 왜 구현에 관련된 인스턴스가 있는가? 바로 다리 역할을 해주므로!
  //해당 필드가 두 클래스 계층의 '다리' 역할을 하는 것이다.
  private MorseCodeFunction function;

  public MorseCode(MorseCodeFunction function) {
    this.function = function;
  }

  public void dot() {
    function.dot();
  }

  public void dash() {
    function.dash();
  }

  public void space() {
    function.space();
  }
}

public class PrintMorseCode extends MorseCode {

  public PrintMorseCode(MorseCodeFunction function) {
    super(function);
  }

  //blue 모스부호 기능
  public PrintMorseCode b() {
    dash();dot();dot();dot();space();
    return this;
  }

  public PrintMorseCode l() {
    dot();dash();dot();dot();space();
    return this;
  }

  public PrintMorseCode u() {
    dot();dot();dash();space();
    return this;
  }

  public PrintMorseCode e() {
    dot();space();
    return this;
  }
}

~~~

blue라는 모스부호의 기능을 추가한 것이다.

여기까지가 기능의 클래스 계층이고, 다음으로는 구현의 클래스 계층을 살펴보자.

---

구현 클래스의 계층을 살펴보자.

~~~java
public interface MorseCodeFunction {
  public void dot();
  public void dash();
  public void space();
}

public class DefaultMCF implements MorseCodeFunction{

  @Override
  public void dot() {
    System.out.print("·");
  }

  @Override
  public void dash() {
    System.out.print("-");
  }

  @Override
  public void space() {
    System.out.print(" ");
  }
}
~~~

구현 단계에서 DefaultMCF 클래스는 MorseCodeFunction의 하위 클래스로서, dot, dash, space의 구체적인 부분을 구현하고 있다.

---

이제 기능과 구현은 따로 분리가 되어 있다. 이제 브릿지를 통해서 기능과 구현을 조합해서 사용해보자.

~~~java
public class BridgeMain {
  public static void main(String[] args) {
    PrintMorseCode printMorseCode = new PrintMorseCode(new DefaultMCF());
    printMorseCode.b().l().u().e();
  }
}
~~~

MorseCodeFunction의 하위 클래스인 DefaultMCF를 PrintMorseCode의 인자로 주어 기능들의 구체적인 구현을 담당하고 있는 것이다. 또한, 이런 것이 가능한 이유는 MorseCodeFunction을 MorseCode에서 의존하고 있어 가능한 것이고 이것이 바로 다리 역할을 하는 것이다.

---

음성 모스 부호 추가 될 시 

~~~java
public class SoundMCF implements MorseCodeFunction{
  @Override
  public void dot() {
    System.out.print("삣");
  }

  @Override
  public void dash() {
    System.out.print("삐~");
  }

  @Override
  public void space() {
    System.out.print(" ");
  }
}

public class BridgeMain {
  public static void main(String[] args) {
    PrintMorseCode printMorseCode = new PrintMorseCode(new FlashMCF());
    printMorseCode.b().l().u().e();
  }
}
//실행 결과
//-*-### #-*-## ##-*- #
~~~

결론적으로, 다시 말해 기능을 추가하고 싶으면 기능의 클래스 계층에 클래스를 추가하면 되고, 구현을 추가하고 싶으면 구현의 클래스 계층에 추가하면 되는 것이다.(FlashMCF) 중요한 것은 이 때 구현이든 기능이든 다른 계층의 클래스들은 전혀 수정할 필요가 없다는 것이다. 이 점은 유지보수 측면에서 매우 간단한 수정이 가능하므로 효율적인 패턴이지만 많이 사용하지는 않는다.

***왜 브릿지 패턴은 사용하지 않지?***