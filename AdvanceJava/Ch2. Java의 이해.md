## Java의 이해 : Java 기본 구조

### 인터페이스의 사용

- 조건이 충족이 되면 클래스 외부에 알려주고자 할 때 인터페이스를 사용한다.
- 클래스를 구현했는데, 해당 클래스의 내부 구현을 외부에 보여주고 싶지 않을 시 인터페이스를 활용하여 서브 클래승세ㅓ 객체를 구현하고, 인터페이스를 외부에 공개하는 것이다.
- 어떤 클래스에 특별한 기능을 주고 싶을 때, 예를 들어 객체를 비교하는 기능을 넣고 싶을 때 인터페이스를 활용한다.
  - 이 때는, Comparable을 implements해서 객체 비교의 기능을 넣어주는 것이다.



### 어노테이션

- 어노테이션은 코드의 로직과는 관계가 없고, 클래스, 메소드, 필드에 메타 데이터를 제공해주는 것이다.
  - 즉, 데이터를 위한 데이터로서, 데이터에 대한 설명을 말한다.
- @Override, @Deprecated, @SuppressWarnings, @Retention, @Target
- @Retention
  - CLASS : 컴파일 시점에 로드되는 시점까지 적용
- @Target
  - 해당 어노테이션을 어디 앞에 적용할 것인지를 말한다.
    - TYPE : Class, Interface, Enum에서 사용가능하다.
    - METHOD : 메소드에 사용가능하다.
    - FIELD : 필드에서 사용가능하다.
    - CONSTRUCTOR : 생성자에서 사용가능하다.
    - PACKAGE
    - PARAMETER
    - LOCAL_VARIABLE : 로컬 변수에 사용 가능하다.
    - ANNOTATIION_TYPE : 어노테이션을 정의할 때 사용가능하다.



### 생성자

- 기본 생성자없이 매개변수를 받는 생성자를 만들 시 기본 생성자는 사용할 수 없다.
- 매개변수를 받는 생성자를 만들고, 기본 생성자도 사용하고 싶으면 둘다 정의해야 한다.



### Modifier

- 함수, 메소드, 클래스, 인터페이스, 필드, 생성자들의 속성을 말한다.

- **Modifer가 어디에서 사용 가능한지를 나타내는 표이다.**

  ![image](https://user-images.githubusercontent.com/40616436/74099543-4f757080-4b68-11ea-9120-c388162ffe74.png)

  - Final
    - Method : 재정의가 불가능하다.
  - native
    - Method : 메소드 구현이 java가 아닌 c로 구현되어 있다.
  - static
    - 멀티 스레드를 사용할 시 변수가 의도치 않게 변경이 발생할 수 있다.
  - synchronized
    - 멀티 스레드 환경에서 순서적으로 접근가능할 수 있도록 해주는 것이다.
    - 동기화 처리
  - transient
    - field : 메모리에서만 값을 유지한다.
    - 해당 변수는 Serializable로 사용하지 않겠다.
    -  Serializable : 객체를 파일에서 사용하거나 파일에서 읽어올 시, 혹은 객체를 바이트 배열로 사용할 때 해당 객체들을 Serializable한 객체로 표현된다. 
  - Volatile
    - Field : 메모리에서 값을 읽어와서 사용하고, 처리가 종료되면 메모리에 다시 저장한다.
      - **캐시의 메모리를 가져와서 사용하지 않는다!**
      - 멀티 스레드 환경에서 동시 접근에 의한 값 변경에 대응할 수 있다.
  - strictfp
    - 보통 부동 소수점 연산은 하드웨어의 기능을 이용해서 연산을 진행한다.
    - 메소드 혹은 클래스에 적용을 하면 각 연산은 Java에서 연산을 진행하여 하드웨어에 상관없이 연산이 가능하다.



### 접근 제한자

- private : 같은 Class
- protected : 같은 Class || 상속받은 Class
- Public : 모두 가능
- default/없음 : 같은 패키지 내에서 사용 가능



### static

- 변수에 사용할 시 **클래스 변수**라고 한다.

  - 즉, 객체를 인스턴스화 하지 않아도 해당 변수를 사용할 수 있다.

- 일반적으로 필드에 static을 사용할 때는, final static을 붙어 상수화 시킨 변수에 사용한다.

- 필드에 static만 붙이는 경우는 **싱글톤**을 사용할 때 붙이는 경우가 많다.

- **팩토링 기법을 사용해서 메소드를 만들 때 Static을 붙인다.**

- **static이 초기화되는 시점은 클래스가 로딩되는 시점에 초기화된다.**

- 클래스 변수는 같은 프로세스 안에서 공유할 수 있다.

  

### final

- final은 변수는 한번 할당 시 변경되지 않고, 한번만 할당 될 수 있다.
- Final 클래스는 상속을 못해주고, Final 메소드는 재정의가 불가능하다.



### 상속에서 생성자

- **생성자는 상속을 받지 못한다.** 즉, 각 객체마다 생성자는 필히 존재해야한다.
- 슈퍼 클래스가 기본 생성자가 아닌 이상 서브 클래스에서는 슈퍼 클래스의 생성자를 명시해줘야 한다.
  - super(각 파라미터);
  - 단, 슈퍼 클래스가 기본 생성자인 경우에는 따로 명시해주지 않아도 된다.
  - 또한, 슈퍼 클래스에 기본 생성자 뿐만 아니라 파라미터를 가진 생성자가 존재하는 경우에는 서브 클래스에서 명시해주지 않아도 된다.                                                                                                                                                                                                                                                                                                                                                                                                                                              









