## 추상클래스와 인터페이스

### 추상 메소드의 구현 강제성

**추상 클래스**

- 추상 클래스는 클래스 내에 추상 메소드가 하나 이상 포함거나 abstract로 정의된 경우를 말한다.

**인터페이스**

- 인터페이스는 모든 메소드가 추상 메소드인 경우를 말한다.

**추상 클래스와 인터페이스는 상속받는 하위 클래스 혹은 구현 클래스에서 추상 메소드를 구현하도록 강제한다**



---

### 추상클래스와 인터페이스 목적

그렇다면 의문이 들 수 있다. 인터페이스는 왜 필요하지? 그냥 추상 클래스로 인터페이스 역할까지 하면 되는거 아닌가? **둘은 존재 목적이 다르다.**

- 추상클래스는 해당 **추상 클래스를 상속받아서 확장**하기 위해 존재하는 것이다.
  - 추상 클래스는 단일 상속만 받아서 확장을 하고자 하는 것이다.
- 인터페이스는 **구현한 객체들이 동일한 동작을 약속**하기 위해 존재하는 것이다.
  - 인터페이스는 다중 상속이 가능하여 **동일한 개념의 기능을 하는 클래스들을 묶는다**는 개념을 가지고 있다.

---

### 추상클래스와 인터페이스 특징

**추상 클래스**

- 추상 클래스는 abstract와 final을 동시에 사용할 수 없다.

- 추상 클래스를 상속 받는 클래스는 추상 메소드를 강제적으로 구현해야하는데, 만약 상속받는 클래스 또한 추상 클래스라면 강제적으로 구현하지 않아도 된다.

- 추상 클래스에서도 인터페이스를 구현할 수 있는데, 이때 인터페이스의 추상 메소드를 구현하지 않고 냅둘 수 있다.

- 추상 클래스는 생성자를 가질 수 있으나, 인스턴스화를 할 시에는 **추상 클래스를 상속받는 하위 클래스에서 인스턴스화**를 해야한다. 아니면, **main에서 추상 메소드를 구현**해야 한다.

  ```java
  //추상 class : Circle
  //구현 class : Point
  Circle circle = new Point(1, 2);
  
  //main에서 추상 메소드 구현
  public static void main(String[] args) {
      Circle circle = new Circle(3) {
          @Override
          public int printCircle(Point point) {
              return 0;
          }
      };
  }
  ```



**인터페이스**

- 인터페이스는 final을 붙일 수 없고, 인터페이스의 변수들은 static이어야만 한다. 즉, **인터페이스는 일반 변수를 가질 수 없다.**

- 인터페이스는 하나 이상의 인터페이스를 상속 받을 수 있다.

  -  `public interface InterfaceA extends InterfaceB, InterfaceC`
  - 이 것은 클래스에서 상속받은게 아니라 인터페이스에서 상속받은 것이니 추상 메소드를 구현하지 않고 그대로 둘수 있다.

- **인터페이스는 생성자를 가질 수 없다.**

  - 인터페이스를 구현한 클래스를 통해 인스턴스화 할 수 있다.

  ```java
  //인터페이스 : InterfaceA
  //구현 클래스 : BookA
  InterfaceA interA = new BookA();
  ```

- 인터페이스의 접근 제한자는 public 혹은 abstract만 가능하다.

- 인터페이스는 `변수 앞에 static final`과 `메소드 앞에 abstract`를 생략할 수 있다. 단, 코드 가독성을 위해 생략하는 습관을 버려라.

- **Java8이 등장하면서 interface의 정의가 몇가지 변경되었다.**

  - default 메소드

    - 인터페이스 안에 default 메소드를 선언하면 인터페이스 안에서도 메소드를 구현할 수 있다.

    ```java
    public interface Calc {
        public pluc(int x, int y);

        //default 메소드
        default int sum(int x, int y) {
            return x+y;
        }
    }
    ```

    - 인터페이스안에 default 메소드를 구현할 시 인터페이스를 구현하는 클래스는 default 메소드를 구현하지 않아도 되고, 오버라이딩 또한 할 수 있다.
    - 이 점은, 인터페이스의 변경에도 구현하는 클래스에 영향을 안 준다는 점에서 매우 메리트가 있다.

  - static 메소드

    - 인터페이스 안에 static 메소드를 선언하여 메소드를 구현할 수 있다.

    ```java
    public interface Calc {
        public pluc(int x, int y);

        //default 메소드
        static int sum2(int x, int y) {
            return x+y;
        }
    }

    //main
    public static void main(String[] args) {
        int sum2 = Calc.sum2(1, 2);
    }
    ```

    - static 메소드를 선언함으로써, 유틸리티성 인터페이스를 만들 수 있게 된 것이다.



**인터페이스보다 추상 클래스의 속도가 더 빠르다! 이유는 인터페이스는 관련된 메소드를 찾기 위해 부가적인 일을 많이 하기 때문이다.**

---

### 추상클래스와 인터페이스 사용 시 확실한 차이

**추상 클래스**

- 추상 클래스를 사용할 때는 필요에 의해서 일반 메소드와 덧붙여 추상화 기능을 더하고자 할 때 추상 클래스를 사용한다.
  - Ex. 사람은 뛴다라는 공통적인 기능이 있고, 뛸 때 팔에 위치나 호흡이 달라질 수 있다. 이 때 팔에 위치나 호흡은 사람마다 다르므로 추상 메소드로 두어  각 사람 객체마다 다르게 구현하면 되는 것이다.
- 추상 클래스는 **상속에 대한 계층 구조가 명확히 표현될 때 사용한다.**



**인터페이스**

- 인터페이스는 디자인을 구성하는 요소가 자주 바뀔 때 쓰면 유용하다.
- 인터페이스는 사용빈도가 높은데, 그 이유는 동시개발이 가능하기 때문이다.
  - 인터페이스 추상 메소드를 접근하는 클래스는 해당 추상 메소드의 파라미터와 리턴값 그리고 메소드 이름(메소드의 목적)을 이미 알고 있으니 추상 메소드가 구현되기 전에도 개발을 진행할 수가 있다.
- 인터페이스를 사용할 시 해당 추상 메소드의 내용을 변경하더라도, 해당 인터페이스를 상속 받는 여러 클래스에는 영향을 받지가 않는다.
