## Exception

**예외란,**

예외는 원하지 않는 또는 예기치 않은 이벤트로, 프로그램 실행 중, 
즉 런타임에 발생하여 프로그램 명령의 정상적인 흐름을 방해합니다.


**오류와 예외**

 - 오류 :  오류는 합리적인 응용 프로그램이 포착하려고하지 않아야하는 심각한 문제를 나타냅니다. 
 - 예외 :  예외는 합리적인 응용 프로그램이 포착하려고하는 조건을 나타냅니다.


**예외계층**

모든 예외 및 오류 유형은 계층의 기본 클래스 인 Throwable 클래스의 하위 클래스입니다 .
하나의 브랜치에는 Exception이 있습니다. 
이 클래스는 사용자 프로그램이 잡아야하는 예외적 인 조건에 사용됩니다. 
NullPointerException은 이러한 예외의 예입니다. 
또 다른 분기 인 Error 는 Java 런타임 시스템 ( JVM )에서 런타임 환경 자체 (JRE)와 관련된 오류를 표시하기 위해 사용됩니다. 
StackOverflowError는 이러한 오류의 예입니다.


**JVM이 예외를 처리하는 방법**

기본 예외 처리 : 메소드 내부에서 예외가 발생하면 메소드는 예외 오브젝트라는 오브젝트를 작성하고이를 런타임 시스템 (JVM)으로 전달합니다. 
예외 개체에는 예외의 이름과 설명, 예외가 발생한 프로그램의 현재 상태가 포함됩니다. 
예외 객체를 생성하여 런타임 시스템으로 처리하는 것을 예외 발생이라고합니다. 
예외가 발생한 메서드를 얻기 위해 호출 된 메서드 목록이있을 수 있습니다. 
이 순서화 된 메소드 목록을 호출 스택 이라고합니다 . 
이제 다음 절차가 수행됩니다.

 - 런타임 시스템은 호출 스택을 검색하여 발생한 예외를 처리 할 수있는 코드 블록이 포함 된 메소드를 찾습니다. 코드 블록을 예외 처리기 라고 합니다 .
 - 런타임 시스템은 예외가 발생한 메소드에서 검색을 시작하고 메소드가 호출 된 역순으로 호출 스택을 진행합니다.
 - 적절한 핸들러를 찾으면 발생한 예외를 전달합니다. 적절한 처리기는 예외 개체 유형이 처리 할 수있는 예외 개체 유형과 일치한다는 것을 의미합니다.
 - 런타임 시스템이 호출 스택에서 모든 메소드를 검색하고 적절한 핸들러를 찾을 수없는 경우 런타임 시스템은 예외 시스템을 런타임 시스템의 일부인 기본 예외 핸들러 로 인계합니다 . 이 핸들러는 다음 형식으로 예외 정보를 인쇄하고 프로그램을 비정상적으로 종료합니다 .

~~~
스레드 "xxx"의 예외 예외 이름 : 설명
... ...... .. // 콜 스택
~~~

호출 스택의 흐름을 이해하려면 아래 다이어그램을 참조하십시오.



**프로그래머는 예외를 어떻게 처리하는가?**

사용자 정의 예외 처리 : Java 예외 처리는 try , catch , throw , throws 및 finally라는 다섯 가지 키워드를 통해 관리됩니다 . 
간단히, 여기 그들이 작동하는 방법입니다. 
예외를 발생시킬 수 있다고 생각되는 프로그램 설명은 try 블록 내에 포함됩니다. 
try 블록 내에서 예외가 발생하면 예외가 발생합니다. 코드는 catch 예외를 사용하여이 예외를 포착하고 합리적인 방식으로 처리 할 수 ​​있습니다. 
시스템 생성 예외는 Java 런타임 시스템에서 자동으로 발생합니다. 예외를 수동으로 발생 시키려면 키워드 throw를 사용하십시오 . 
A가에 의한 방법을 밖으로 던져되는 모든 예외는 다음과 같은 지정해야합니다 
발생절. try 블록이 완료된 후에 절대적으로 실행되어야하는 모든 코드는 finally 블록에 배치됩니다.


**try-catch 절을 사용하는 방법**

~~~

{
// 오류를 모니터링하는 코드 블록
// 예외를 일으킬 수 있다고 생각되는 코드
}
catch (ExceptionType1 exOb) {
// ExceptionType1에 ​​대한 예외 처리기
}
catch (ExceptionType2 exOb) {
// ExceptionType2에 대한 예외 처리기
}
// 선택 사항
드디어 {
// try 블록 종료 후 실행될 코드 블록
}

~~~




**참고**
https://wikidocs.net/229
