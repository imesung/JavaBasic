## 제네릭

### 제네릭이란 무엇인가?

**제네릭은 간단히 말해 데이터 타입을 명시하지 않은 상태를 말한다.**

**쉽게 생각해보면 클래스의 데이터 타입을 미리 정의하지 않고, 클래스가 인스턴스화 되는 시점에 데이터 타입을 지정해주는 방식이다.**

제네릭은 `<>`를 활용하여 구현한다.



### 제네릭을 사용하는 이유는 무엇인가?

제네릭을 사용하는 이유 즉, 장점을 살펴보겠다.

1. **제네릭을 활용하면 강제적인 타입 변환이 발생하지 않아 성능 저하를 방지할 수 있다.**
2. **중복 코드를 제거하고 코드의 재사용성을 증진시킨다.**
3. **컴파일 시에 타입 오류를 체크하여 안정적으로 데이터 타입을 체크할 수 있다.**



하나씩 코드와 함께 살펴보자.



- **제네릭을 활용하면 강제적인 타입 변환이 발생하지 않아 성능 저하를 방지할 수 있다.**

제네릭을 사용하지 않는 코드를 확인해보자

```java
public class Book {
    private Object obj;
    public Object get() {
        return obj;
    }
    public set(Object obj) {
        this.obj = obj;
    }
}

//main
public class Main {
    public static void main(String [] args) {
        Book book = new Book();
        book.set("제네릭 공부");
        String str = book.get();	//컴파일 에러 발생
        System.out.println(str);
    }
}
```

컴파일 에러가 발생한 이유는, **book에서 꺼내온 값은 Object 타입의 변수이므로 String으로 타입 형변환을 해줘야한다**



제네릭을 사용한 코드를 보자.

```java
public class Book<T> {
    private T t;
    public T get() {
        return t;
    }
    public set(T t) {
        this.t = t;
    }
}

//main
public class Main {
    public static void main(String [] args) {
        Book<String> book = new Book<String>();
        book.set("제네릭 공부");
        String str = book.get();
        System.out.println(str);
    }
}
```

위 처럼 <T>의 제네릭을 활용하여 Book 클래스를 정의하고, Book 클래스를 인스턴화 할 때 String 타입으로 정해주므로 **강제적인 타입 형변환은 발생하지 않는다.**



- **중복 코드를 제거하고 코드의 재사용성을 증진시킨다.**

만약 제네릭을 사용하지 않고, Book의 String 타입뿐만 아니라 Integer, Boolean 등의 Wrraper Class를 사용하려고 할 시 **타입만 다르고 내용은 같은 Book 클래스를 여러개 만들어야 한다.**

제네릭을 사용함으로써, 이런 중복 코드 또한 제거할 수 있는 것이다.



- **컴파일 시에 타입 오류를 체크하여 안정적으로 데이터 타입을 체크할 수 있다.**

```java
class MyList<T> {
    private Object [] obj;
    private int index;

    public MyList() {
        obj = new Object[10];
        index = 0;
    }

    public void add(T t) {
        this.obj[index++] = t;
    }

    public T get() {
        return (T) obj[index--];
    }
}

public class CompileTest {
    public static void main(String[] args) {
        MyList<String> myList = new MyList<String>();
        myList.add("제네릭");
        myList.add("스터디");
        myList.add(1);  //컴파일 오류 발생
    }
}
```

이 처럼 Collection을 만들 때, 제네릭을 사용할 시 개발자가 원하는 타입의 데이터가 아닌 다른 데이터가 들어가면 컴파일 오류가 발생하게 된다. 즉, **안전하게 해당 타입에 맞는 List를 만들 수 있어 버그나 에러를 줄일 수 있다.**

