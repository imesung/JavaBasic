## Java Virtual Machine

### JVM이란

**Java 애플리케이션을 클래스 로더를 통해 읽어 들여 Java API와 함께 실행하는 것을 말한다.**

JVM은 **Java와 OS 사이에서 중개자 역할을 하며 Java가 OS에 구애받지 않고 재사용**을 가능하게끔 해준다.

JVM은 **스택기반의 가상머신으로 메모리 관리와 Garbage Collection을 수행**한다.



**우리는 왜 JVM을 알아야 할까?**

메모리는 한정되어 있고 우리는 이 한정된 메모리에 안에서 프로그램을 실행해야하니 메모리를 최대한 효율적으로 사용해야 하는 것이다.

메모리를 효율적으로 사용하기 위해서는 **메모리 구조를 알고 메모리 관리가 어떤 식으로 되는 진행되는 지 파악하여 그 입맛에 맞게 개발을 해야한다.**



### **JAVA 프로그램의 실행 과정을 살펴보자**

1. 우리가 작성한 Java를 실행하면 JVM은 OS로부터 메모리를 할당받는다.
2. JVM은 할당받은 메모리를 용도에 따라 여러 영역으로 나누어 관리힌다.
3. 그 후 **Java 컴파일러(javac)**가 **java 소스 코드(.java)**를 읽어드려 **java 바이트 코드(.class)**로 변환시킨다.
4. 변환 시킨 java 바이트 코드는 **클래스 로더**를 통해 JVM에 로딩된다.
5. JVM에 로딩된 **java 바이트 코드는 Execution Engine에 의해 해석**된다.
6. 해석이 완료되면 java 바이트 코드는 Runtime Data Areas에 배치되어 실질적인 수행이 이루어진다.



![image](https://user-images.githubusercontent.com/40616436/73047681-f0ea9a00-3eb9-11ea-9cf6-ea1128985c9d.png)

**클래스 로더(Class Loader)**

Runtime 시에 동적으로 바이트 코드(.class)를 JVM내로 로드하고 Linking을 통해 배치하는 작업을 수행한다.

jar파일 내 저장된 클래스들을 JVM 위에 탑재하고 사용하지 않는 클래스들은 메모리에서 삭제한다.(컴파일러 역할)



**실행엔진(Execution Engine)**

Java 바이트 코드는 인간이 보기 편한 형태로 기술된 것이다. 그래서 실행 엔진은 Java 바이트 코드를 JVM 내부에서 기계가 실행할 수 있는 형태로 변경하는 역할을 한다.



**인터프리터(Interpreter)**

Java 바이트 코드를 읽을 수 있도록 하는 역할이다. 그러나 Java 바이트 코드를 한줄 씩 읽어 수행 속도가 매우 느리다는 인터프리터 언어 단점을 그대로 안고 있다.



**JIT 컴파일러**

인터프리터 방식의 단점을 보완하기 위해 도입된 것이다.

처음에는 인터프리터 방식으로 실행하다가 적절한 시점에 Java 바이트 코드 전체를 컴파일하여 **네이티브 코드**로 변경하고 그 이후에는 인터프리터 방식이 아닌 네이티브 코드로 직접 실행하는 방식이다.

네이티브 코드 방식은 캐시에 보관되기 때문에 한번만 컴파일 되면 빠르게 수행할 수가 있다. 그러나 인터프리팅하는 것보다 오래 걸리므로 한번만 컴파일 되는 코드라면 인터프리터 하는 것이 유리할 것이다.

JIT 컴파일러를 사용하는 JVM들은 내부적으로 해당 메서드가 얼마나 자주 사용되는 지 확인하여 일정 정도가 넘을 때에만 해당 컴파일을 수행하는 것이다.



**Garbage Collector**

GC를 수행하는 모듈이다.



### Runtime Data Area

프로그램을 수행하기 위해 OS에서 할당받은 메모리 공간이다.

![image](https://user-images.githubusercontent.com/40616436/73051988-56915300-3ec7-11ea-8afd-12b0725f6ef3.png)

**PC Register**

Thread가 시작될 때 생성되며 스레드마다 하나씩 존재한다.

현재 수행중인 JVM 명령의 주소를 갖고 있고, **Thread가 어떤 부분을 어떤 명령으로 실행해야할 지에 대한 기록**을 하는 역할을 가진다.



**JVM Stack Area**

프로그램 실행 과정에서 임시로 할당되었다가 메소드 범위를 벗어나면 소멸되는 특성의 데이터를 저장하기 위한 영역이다.

메소드 호출 할때마다 메소드만을 위한 공간을 생성하고, 메소드 수행이 끝나면 삭제한다.

메소드의 매개변수, 지역변수, 리턴 값, 연산 시 결과 값들을 임시로 저장한다.



**Native Method Stack**

컴파일러에 의해 생성된 Java 바이트 코드가 아닌 기계가 실행할 수 있는 형태인 기계어를 실행시키는 영역이다.

Java 외 다른 언어로 작성된 코드만을 위한 공간이고, 일반 프로그램처럼 커널이 스택을 잡아 독자적으로 프로그램을 실행시키는 영역이다.



**Heap Area**

객체를 저장하는 가상 메모리 공간이다.

new 연산자를 활용하여 생성된 객체와 배열을 저장하되, class 영역에 올라온 클래스만 객체로 생성할 수 있다.

![image](https://user-images.githubusercontent.com/40616436/73051937-424d5600-3ec7-11ea-8a62-bdcf20b7b717.png)

Permanent Generation

생성된 객체 정보의 주소값이 저장되는 공간이다.

클래스 로더에 의해 로딩된 바이트 코드의 Class, Method 등에 대한 Meta 정보가 저장되는 영역이다.

Reflection을 사용하여 동적으로 클래스가 로딩되는 경우에 사용된다.



New/Young Generation

- Eden : 객체들이 최초로 생성되는 공간이다.
- Survivor 0 /1 : Eden 영역에서 참조되는 객체들이 저장되는 공간이다.
- 이 영역에서 발생되는 GC를 Minor GC라고 하며 Major GC에 비해 속도가 빠르다.



 Old Generation

New/Young 영역에서 일정시간 **참조되고 있는 객체들 중 생명 주기가 긴(오래된 객체)**를 GC 대상으로 정하는 여역이다.

이 영역에서 발생되는 GC를 Major GC라고 칭하고 Minor GC에 비해 속도가 느리다.



**Method Area(Class Area && Static Area)**

클래스 정보를 처음 메모리 공간에 올릴 때 초기화 되는 대상을 저장하기 위한 메모리 공간이다.

올라가는 정보를 살펴보자

**Field Information** : 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보

**Method Information** : 메서드의 이름, 리턴 타입, 매개변수, 접근제어자 정보

**Type Information** : class인지 interface인지의 여부를 저장

- Type의 전체 이름(패키지명 + 클래스명)
- Type의 Super Class의 전체 이름(단, Type이 Inteface거나 Object 클래스인 경우는 제외)
- 접근제어자

**Constant Pool(상수 풀)**

- Type에서 사용된 상수를 저장
- 문자 상수, 타입, 필드, Method의 Symbolic Reference(객체 이름으로 참조하는 것을 말함)도 상수 풀에 저장

**Class Variable(Static 변수)**

- 모든 객체가 공유할 수 있고, 객체 생성 없이 접근이 가능

**Class 사용 이전에 메모리 할당**

- final class 변수의 경우는 상수 풀에 값을 복사